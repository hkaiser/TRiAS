#define YY_DEFAULT_ACTION ECHO;
/* A lexical scanner generated by pclex */

#define YY_END_TOK 0
#define YY_NEW_FILE -1
#define YY_DO_DEFAULT -2
#define F_BUFSIZ 128
#define YY_BUF_SIZE (F_BUFSIZ * 2)
#define YY_BUF_MAX (YY_BUF_SIZE - 1)
#ifndef YY_MAX_LINE
#define YY_MAX_LINE F_BUFSIZ
#endif
#define YY_BUF_LIM (YY_BUF_MAX - YY_MAX_LINE)
#define ECHO fputs(yytext, yyout)
#define YY_INPUT(buf,result,max_size) \
	if (fgets(buf, max_size, yyin) != NULL) \
	    result = strlen(buf); \
	else if (!ferror(yyin)) \
	    result = YY_NULL; \
	else \
	    YY_FATAL_ERROR("fgets() in pclex scanner failed");
#define YY_NULL 0
#define YY_OUTPUT(c) fputc(c, yyout);
#define YY_FATAL_ERROR(msg) \
	{ \
	fputs(msg, stderr); \
	putc('\n', stderr); \
	exit(1); \
	}
#define YY_FIRST_CHAR yy_ch_buf[yy_b_buf_p]
#define BEGIN yy_start = 1 +
#define YY_SET_BOL(array,pos) array[pos - 1] = '\n';
#define YY_DECL int yylex()
#define yyless(n) \
	{ \
	YY_DO_BEFORE_SCAN; \
	yy_c_buf_p = yy_b_buf_p + n - 1; \
	YY_DO_BEFORE_ACTION; \
	}
#define YY_BREAK break;
#define YY_INIT \
	{ \
	yyleng = yy_c_buf_p = yy_e_buf_p = 0; \
	yy_hold_char = yy_ch_buf[yy_c_buf_p] = '\n'; \
	yytext = &yy_ch_buf[yy_c_buf_p]; \
	yy_saw_eof = 0; \
	}
#define YY_LENG (yy_c_buf_p - yy_b_buf_p + 1)
#define YY_DO_BEFORE_SCAN \
	yytext[yyleng] = yy_hold_char;
#define YY_DO_BEFORE_ACTION \
	yytext = &yy_ch_buf[yy_b_buf_p]; \
	yyleng = YY_LENG; \
	yy_hold_char = yytext[yyleng]; \
	yytext[yyleng] = '\0';
#define REJECT \
        { \
	YY_DO_BEFORE_SCAN; \
	yy_c_buf_p = yy_full_match; \
        ++yy_lp; \
        goto find_rule; \
        }

static int input(void);
static void unput(char);

#define __INITIAL 0
// Scanner fuer GDB - Schnittstelle
// File: GDB.LX

static char SccsId[] = "uve FEZ: %W%  %E%";

#include "stdafx.h"

#include "ytab.h"
#include "gdb.h"

#include "dgeoobj.hxx"
#include "yystype.hxx"

#pragma warning(disable: 4102)

// LEX - RetVal definieren
extern YYSTYPE (*pyylval);

#if !defined(TRUE)
#define TRUE (1)
#endif

int SatzTyp = 0;
int tot_errs = 0;

char InString[1025];

extern int c_flag;		// Kommentarbehandlung

struct keyentry {		// Tabelleneintrag fuer reservierte Worte
	int  lx;
	char *id;
};

struct keyentry keywords[] = {
	{	ENUM, "ENUM"		},
	{	ENUMI, "ENUMI"		},
//	{	STUFE, "STU"		},
	{	SM, "SM"		},
	{	ST, "ST"		},
	{	EB, "EB"		},
	{	0, ""			},
};

// Funktionsprototypen --------------------------------------------------------
void comment (char *, int);
double ReadSicadFloat (char *);

extern FILE *yyout;

int yywrap (void);
#if 0
int yylook (void);
int yyback (int *, int);

void allprint (char);
void sprint (char *);
int printable (int);
#endif

void r_error (char *, int);
void r_abort (char *);
long xtol (char *);

#define HStufe 2
#define EnumHex 4
#define YY_JAM 128
#define YY_JAM_BASE 1140
static char a[275] =
    {   0,
       46,   46,   46,   46,   46,   46,   47,   48,   46,   47,
       48,   45,   48,   43,   47,   48,   47,   48,   47,   48,
       33,   47,   48,   37,   47,   48,   34,   47,   48,   42,
       47,   48,   42,   47,   48,   42,   47,   48,   29,   47,
       48,   16,   31,   42,   47,   48,   31,   42,   47,   48,
       31,   42,   47,   48,   31,   42,   47,   48,   31,   42,
       47,   48,   13,   24,   31,   42,   47,   48,   17,   31,
       42,   47,   48,   12,   31,   42,   47,   48,   31,   42,
       47,   48,   31,   42,   47,   48,   18,   31,   42,   47,
       48,   31,   42,   47,   48,   31,   42,   47,   48,   14,

       31,   42,   47,   48,   10,   31,   42,   47,   48,   11,
       31,   42,   47,   48,   31,   42,   47,   48,   35,   37,
       47,   48,   37,   38,   47,   48,   38,   42,   47,   48,
       16,   31,   38,   42,   47,   48,   31,   38,   42,   47,
       48,   31,   38,   42,   47,   48,   31,   38,   42,   47,
       48,   31,   38,   42,   47,   48,   46,   43,   44,   40,
       39,   37,   42,   42,   42,   31,   42,   31,   42,   31,
       42,   31,   42,   31,   42,   25,   31,   42,   31,   42,
       31,   42,   31,   42,   22,   31,   42,   31,   42,   31,
       42,   31,   42,   31,   42,   35,   37,   37,   38,   38,

       38,   38,   42,   31,   38,   42,   39,   40,   41,   42,
       36,   42,   31,   42,   31,   42,   23,   31,   42,   21,
       31,   42,   26,   31,   42,   19,   31,   42,   20,   31,
       42,   31,   42,   31,   42,   15,   31,   42,   30,   31,
       42,   31,   36,   42,   38,   41,   40,   39,   32,   28,
       31,   42,   31,   42,   31,   42,   39,   40,   31,   42,
       31,   42,    4,    7,    3,    2,    6,    5,    1,    9,
        8,   27,   31,   42
    } ;

static short int l[130] =
    {   0,
       -2,   -2,   -2,   -2,   -2,   -2,    7,    9,   12,   14,
       17,   19,   21,   24,   27,   30,   33,   36,   39,   42,
       47,   51,   55,   59,   63,   69,   74,   79,   83,   87,
       92,   96,  100,  105,  110,  115,  119,  123,  127,  131,
      137,  142,  147,  152,  157,  158,  159,  160,  160,  160,
      161,  162,  163,  163,  164,  165,  166,  168,  170,  172,
      174,  176,  179,  181,  183,  185,  188,  190,  192,  194,
      196,  198,  200,  201,  202,  204,  207,  207,  209,  209,
      209,  210,  211,  213,  215,  217,  220,  223,  226,  229,
      232,  234,  236,  239,  242,  245,  247,  247,  248,  248,

      248,  249,  250,  253,  255,  257,  257,  259,  259,  261,
      261,  261,  261,  261,  261,  261,  261,  263,  264,  265,
      266,  267,  268,  269,  270,  271,  272,  275,  275
    } ;

static short int b[131] =
    {   0,
        0,   86,   81,   91,  129,  152, 1140,  201, 1140,  319,
      186,  196, 1140,  208, 1140,    0,  272,  218, 1140,  262,
        0,  276,  270,  277,    0,    0,  261,  242,  112,    0,
      128,  236,    0,    0,    0,  337,  362,  386,  423,  446,
        0,  244,  238,  245,  269,  281, 1140,  372,  471,  481,
      505,  539,  566,    0,  220,  576,    0,  236,  213,  124,
      223,    0,  207,  214,  221,    0,  207,  218,  206,  599,
      624,  648,  685,  713,    0,    0,  741,  751,  773,  634,
      783,  220,    0,  211,  199,    0,    0,    0,    0,    0,
      177,  170,    0,    0,    0,  793,  816,  826,  841,  851,

      861, 1140,    0,  169,  142,  871,  881,  223,  156,  144,
      140,  129,  140,  153,   99,   62,   67, 1140, 1140, 1140,
     1140, 1140, 1140, 1140, 1140, 1140,    0, 1140,  938, 1018
    } ;

static short int d[131] =
    {   0,
      128,    1,    1,    2,    1,    2,  128,  128,  128,  129,
      128,  128,  128,  128,  128,  130,  130,  130,  128,  128,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,  128,  128,  130,   20,
       40,   40,   40,   40,  128,  129,  128,  128,  128,  128,
      128,  128,  128,  130,  130,  130,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
      128,  128,  128,  128,   39,   40,  128,  128,  128,  128,
      128,  130,   18,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   36,  128,  128,  128,  128,  128,

      128,  128,   20,   20,   20,  128,  128,  128,   20,  128,
      128,  128,  128,  128,  128,  128,   20,  128,  128,  128,
      128,  128,  128,  128,  128,  128,   20,-32767,  128,  128
    } ;

static short int n[1268] =
    {   0,
        7,    7,    7,    7,    7,    7,    7,    7,    8,    9,
        7,    7,    8,    7,    7,    7,    7,    7,    7,    7,
        7,    7,    7,    7,    7,    8,    7,    7,    7,    7,
        7,    8,    7,    7,    7,    7,    7,    7,   10,    7,
        7,    7,   11,    7,   11,   12,   13,   14,   14,   14,
       14,   14,   14,   14,   14,   14,   14,    7,    7,    7,
       15,    7,    7,    7,   16,   16,   16,   16,   16,   16,
       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
       16,   16,   17,   16,   16,   16,   16,   16,   16,   18,
        7,    7,    7,    7,   16,    7,   16,   16,   16,   16,

       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
       16,   16,   16,   16,   16,   16,   16,   16,   16,   16,
       16,   16,    7,    7,    7,    7,    7,   19,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   37,  127,  126,
       20,   21,   22,   21,   23,   24,   21,   25,   21,   21,
       21,   21,   26,   27,   28,   29,   21,   30,   31,   32,
       21,   21,   33,   34,   35,   36,   38,   38,   38,   38,
       38,   38,   38,   38,   38,   38,   63,  125,   86,   64,
       65,   87,   66,   39,   39,   39,   39,   39,   39,   38,

       38,   38,   38,   38,   38,   38,   38,   38,   38,   45,
      120,   67,  121,   45,   68,  119,   40,   41,   42,   41,
       43,   44,  118,  123,  117,  109,   45,  124,  122,  108,
      102,   48,   45,   49,   49,   49,   49,   49,   49,   49,
       49,   49,   49,   50,   50,   50,   50,   50,   50,   50,
       50,   50,   50,   51,  105,   52,   52,   52,   52,   52,
       52,   52,   52,   52,   52,   56,   56,   56,   56,   56,
       56,   56,   56,   56,   56,   53,   53,   45,  104,  103,
      102,   45,   56,   56,   56,   56,   56,   56,  110,   94,
       93,   92,  111,   91,   45,   90,   89,  112,  113,   88,

       45,   85,  114,   84,   82,  115,  116,   53,   53,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   47,
       60,   59,   58,   69,   62,   61,   57,   57,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
       57,   57,   60,   59,   58,   55,   54,   47,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   70,   70,   70,   70,   70,   70,
       70,   70,   70,   70,  128,  128,  128,  128,  128,  128,

      128,   70,   70,   70,   70,   70,   70,   51,  128,   71,
       71,   71,   71,   71,   71,   71,   71,   71,   71,   50,
       50,   50,   50,   50,   50,   50,   50,   50,   50,   53,
       53,   51,  128,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,  128,  128,  128,  128,  128,  128,  128,
       73,   73,   73,   74,   74,   73,  128,  128,  128,  128,
      128,   53,   53,  128,  128,  128,  128,  128,  128,  128,
       75,   75,   75,   75,   75,   75,   75,   75,   75,   75,
      128,  128,  128,  128,  128,   53,   53,   75,   75,   75,
       75,   75,   75,   76,   76,   76,   76,   76,   76,   76,

       76,   76,   76,  128,  128,  128,  128,  128,  128,  128,
       76,   76,   76,   76,   76,   76,   51,  128,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   50,   50,
       50,   50,   50,   50,   50,   50,   50,   50,   53,   53,
      128,  128,  128,  128,  128,  128,  128,  128,   77,   77,
      128,  128,   78,   78,   78,   78,   78,   78,   78,   78,
       78,   78,  128,  128,  128,  128,  128,  128,  128,  128,
       53,   53,   79,   79,  128,  128,  128,  128,  128,  128,
       77,   77,  128,  128,   51,  128,   52,   52,   52,   52,
       52,   52,   52,   52,   52,   52,  128,  128,  128,  128,

      128,  128,  128,  128,   79,   79,   53,   53,   80,  128,
       80,  128,  128,   81,   81,   81,   81,   81,   81,   81,
       81,   81,   81,   83,   83,   83,   83,   83,   83,   83,
       83,   83,   83,  128,  128,  128,  128,  128,   53,   53,
       83,   83,   83,   83,   83,   83,   95,   95,   95,   95,
       95,   95,   95,   95,   95,   95,  128,  128,  128,  128,
      128,  128,  128,   95,   95,   95,   95,   95,   95,   51,
      128,   71,   71,   71,   71,   71,   71,   71,   71,   71,
       71,   81,   81,   81,   81,   81,   81,   81,   81,   81,
       81,   53,   53,   51,  128,   72,   72,   72,   72,   72,

       72,   72,   72,   72,   72,  128,  128,  128,  128,  128,
      128,  128,   73,   73,   73,   74,   74,   73,  128,  128,
      128,  128,  128,   53,   53,  128,  128,  128,  128,  128,
      128,  128,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,  128,  128,  128,  128,  128,   53,   53,   73,
       73,   73,   73,   73,   73,   80,  128,   80,  128,  128,
       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
      128,  128,  128,  128,  128,  128,  128,   73,   73,   73,
       73,   73,   73,   97,  128,   97,  128,  128,   98,   98,
       98,   98,   98,   98,   98,   98,   98,   98,   78,   78,

       78,   78,   78,   78,   78,   78,   78,   78,  128,  128,
      128,  128,  128,  128,  128,  100,  128,  100,   99,   99,
      101,  101,  101,  101,  101,  101,  101,  101,  101,  101,
       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
       99,   99,  128,  128,  128,  128,  128,   73,   73,   73,
       73,   73,   73,   98,   98,   98,   98,   98,   98,   98,
       98,   98,   98,   98,   98,   98,   98,   98,   98,   98,
       98,   98,   98,  106,  128,  106,  128,  128,  107,  107,
      107,  107,  107,  107,  107,  107,  107,  107,  101,  101,

      101,  101,  101,  101,  101,  101,  101,  101,  101,  101,
      101,  101,  101,  101,  101,  101,  101,  101,  107,  107,
      107,  107,  107,  107,  107,  107,  107,  107,  107,  107,
      107,  107,  107,  107,  107,  107,  107,  107,   46,   46,
       46,   46,   46,   46,   46,   46,   46,  128,   46,   46,
      128,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,  128,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,

       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
       46,   46,   46,   46,   46,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,  128,  128,  128,  128,  128,
      128,  128,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,

       54,   54,   54,   54,   54,   54,   54,   54,  128,  128,
      128,  128,   54,  128,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   54,   54,   54,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,

      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128
    } ;

static short int c[1268] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    2,    3,    3,
        3,    3,    3,    3,    3,    3,    3,    3,    4,    4,
        4,    4,    4,    4,    4,    4,    4,    4,  117,  116,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
        2,    2,    2,    2,    2,    2,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,   29,  115,   60,   29,
       29,   60,   31,    5,    5,    5,    5,    5,    5,    6,

        6,    6,    6,    6,    6,    6,    6,    6,    6,    8,
      112,   31,  113,    8,   31,  111,    6,    6,    6,    6,
        6,    6,  110,  114,  109,  105,    8,  114,  113,  104,
       92,   11,    8,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   12,   12,   12,   12,   12,   12,   12,
       12,   12,   12,   14,   91,   14,   14,   14,   14,   14,
       14,   14,   14,   14,   14,   18,   18,   18,   18,   18,
       18,   18,   18,   18,   18,   14,   14,   45,   85,   84,
       82,   45,   18,   18,   18,   18,   18,   18,  108,   69,
       68,   67,  108,   65,   45,   64,   63,  108,  108,   61,

       45,   59,  108,   58,   55,  108,  108,   14,   14,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   46,
       44,   43,   42,   32,   28,   27,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   24,   23,   22,   17,   20,   10,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   36,   36,   36,   36,   36,   36,
       36,   36,   36,   36,    0,    0,    0,    0,    0,    0,

        0,   36,   36,   36,   36,   36,   36,   37,    0,   37,
       37,   37,   37,   37,   37,   37,   37,   37,   37,   48,
       48,   48,   48,   48,   48,   48,   48,   48,   48,   37,
       37,   38,    0,   38,   38,   38,   38,   38,   38,   38,
       38,   38,   38,    0,    0,    0,    0,    0,    0,    0,
       38,   38,   38,   38,   38,   38,    0,    0,    0,    0,
        0,   37,   37,    0,    0,    0,    0,    0,    0,    0,
       39,   39,   39,   39,   39,   39,   39,   39,   39,   39,
        0,    0,    0,    0,    0,   38,   38,   39,   39,   39,
       39,   39,   39,   40,   40,   40,   40,   40,   40,   40,

       40,   40,   40,    0,    0,    0,    0,    0,    0,    0,
       40,   40,   40,   40,   40,   40,   49,    0,   49,   49,
       49,   49,   49,   49,   49,   49,   49,   49,   50,   50,
       50,   50,   50,   50,   50,   50,   50,   50,   49,   49,
        0,    0,    0,    0,    0,    0,    0,    0,   50,   50,
        0,    0,   51,   51,   51,   51,   51,   51,   51,   51,
       51,   51,    0,    0,    0,    0,    0,    0,    0,    0,
       49,   49,   51,   51,    0,    0,    0,    0,    0,    0,
       50,   50,    0,    0,   52,    0,   52,   52,   52,   52,
       52,   52,   52,   52,   52,   52,    0,    0,    0,    0,

        0,    0,    0,    0,   51,   51,   52,   52,   53,    0,
       53,    0,    0,   53,   53,   53,   53,   53,   53,   53,
       53,   53,   53,   56,   56,   56,   56,   56,   56,   56,
       56,   56,   56,    0,    0,    0,    0,    0,   52,   52,
       56,   56,   56,   56,   56,   56,   70,   70,   70,   70,
       70,   70,   70,   70,   70,   70,    0,    0,    0,    0,
        0,    0,    0,   70,   70,   70,   70,   70,   70,   71,
        0,   71,   71,   71,   71,   71,   71,   71,   71,   71,
       71,   80,   80,   80,   80,   80,   80,   80,   80,   80,
       80,   71,   71,   72,    0,   72,   72,   72,   72,   72,

       72,   72,   72,   72,   72,    0,    0,    0,    0,    0,
        0,    0,   72,   72,   72,   72,   72,   72,    0,    0,
        0,    0,    0,   71,   71,    0,    0,    0,    0,    0,
        0,    0,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,    0,    0,    0,    0,    0,   72,   72,   73,
       73,   73,   73,   73,   73,   74,    0,   74,    0,    0,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
        0,    0,    0,    0,    0,    0,    0,   74,   74,   74,
       74,   74,   74,   77,    0,   77,    0,    0,   77,   77,
       77,   77,   77,   77,   77,   77,   77,   77,   78,   78,

       78,   78,   78,   78,   78,   78,   78,   78,    0,    0,
        0,    0,    0,    0,    0,   79,    0,   79,   78,   78,
       79,   79,   79,   79,   79,   79,   79,   79,   79,   79,
       81,   81,   81,   81,   81,   81,   81,   81,   81,   81,
       96,   96,   96,   96,   96,   96,   96,   96,   96,   96,
       78,   78,    0,    0,    0,    0,    0,   96,   96,   96,
       96,   96,   96,   97,   97,   97,   97,   97,   97,   97,
       97,   97,   97,   98,   98,   98,   98,   98,   98,   98,
       98,   98,   98,   99,    0,   99,    0,    0,   99,   99,
       99,   99,   99,   99,   99,   99,   99,   99,  100,  100,

      100,  100,  100,  100,  100,  100,  100,  100,  101,  101,
      101,  101,  101,  101,  101,  101,  101,  101,  106,  106,
      106,  106,  106,  106,  106,  106,  106,  106,  107,  107,
      107,  107,  107,  107,  107,  107,  107,  107,  129,  129,
      129,  129,  129,  129,  129,  129,  129,    0,  129,  129,
        0,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,    0,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,

      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  129,  129,  129,  129,  129,
      129,  129,  129,  129,  129,  130,  130,  130,  130,  130,
      130,  130,  130,  130,  130,    0,    0,    0,    0,    0,
        0,    0,  130,  130,  130,  130,  130,  130,  130,  130,
      130,  130,  130,  130,  130,  130,  130,  130,  130,  130,

      130,  130,  130,  130,  130,  130,  130,  130,    0,    0,
        0,    0,  130,    0,  130,  130,  130,  130,  130,  130,
      130,  130,  130,  130,  130,  130,  130,  130,  130,  130,
      130,  130,  130,  130,  130,  130,  130,  130,  130,  130,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,

      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128,  128,  128,  128,
      128,  128,  128,  128,  128,  128,  128
    } ;


FILE *yyin = stdin, *yyout = stdout;
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof = 1, yy_init = 1;
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;
char *yytext;
int yyleng;

static int input(void)
{
  int c;

  YY_DO_BEFORE_SCAN
  if (yy_c_buf_p == yy_e_buf_p) {
    int yy_n_chars;

    if (yy_saw_eof) {
      if (yywrap())
	 return (EOF);

      YY_INIT;
    }

    yy_b_buf_p = 0;
    YY_INPUT(yy_ch_buf, yy_n_chars, YY_MAX_LINE);

    if (yy_n_chars == YY_NULL) {
      yy_saw_eof = 1;

      if (yywrap())
	return (EOF);

      YY_INIT;
      return (input());
    }

    yy_c_buf_p = -1;
    yy_e_buf_p = yy_n_chars - 1;
  }

  c = yy_ch_buf[++yy_c_buf_p];

  YY_DO_BEFORE_ACTION;

  return (c);
}


static void unput(char c)
{
    YY_DO_BEFORE_SCAN;

    if (yy_c_buf_p == 0) {
	register int i;
	register int yy_buf_pos = YY_BUF_MAX;

	for (i = yy_e_buf_p; i >= yy_c_buf_p; --i) {
	    yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
	    yy_st_buf[yy_buf_pos] = yy_st_buf[i];
	    --yy_buf_pos;
	}

	yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
	yy_e_buf_p = YY_BUF_MAX;
    }

    if (yy_c_buf_p <= 0)
	YY_FATAL_ERROR("pclex scanner push-back overflow");

    if (yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n')
	yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] = c;

    YY_DO_BEFORE_ACTION;
}


YY_DECL
{
  register int yy_curst;
  register char yy_sym;
  int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act, yy_full_match;




  if (yy_init) {
    YY_INIT;
    yy_start = 1;
    yy_init = 0;
  }
  goto get_next_token;

do_action:
  yy_full_match = yy_c_buf_p;

  for ( ; ; )	{
    YY_DO_BEFORE_ACTION

    switch (yy_act) {
case 1:
{	SatzTyp = PUNKT;	}
	YY_BREAK
case 2:
{	SatzTyp = LINIE;	}
	YY_BREAK
case 3:
{	SatzTyp = KREIS;	}
	YY_BREAK
case 4:
{	SatzTyp = BOGEN;	}
	YY_BREAK
case 5:
{	SatzTyp = PUNKTKOORD;	}
	YY_BREAK
case 6:
{	SatzTyp = POLYGON;	}
	YY_BREAK
case 7:
{	SatzTyp = FLAECHE;	}
	YY_BREAK
case 8:
{	SatzTyp = T_TEXT;		}
	YY_BREAK
case 9:
{	SatzTyp = SYMBOL;	}
	YY_BREAK
case 10:
return XSATZ;
	YY_BREAK
case 11:
return YSATZ;
	YY_BREAK
case 12:
return NSATZ;
	YY_BREAK
case 13:
return HSATZ;
	YY_BREAK
case 14:
return WINKEL;
	YY_BREAK
case 15:
return SWINKEL;
	YY_BREAK
case 16:
return ASATZ;
	YY_BREAK
case 17:
return MSATZ;
	YY_BREAK
case 18:
return RADIUS;
	YY_BREAK
case 19:
return PKZSATZ;
	YY_BREAK
case 20:
return PNRSATZ;
	YY_BREAK
case 21:
return FLDSATZ;
	YY_BREAK
case 22:
return SASATZ;
	YY_BREAK
case 23:
return FLASATZ;
	YY_BREAK
case 24:
return HSATZ;
	YY_BREAK
case 25:
return OSSATZ;
	YY_BREAK
case 26:
{	
			// Rest der Zeile einlesen und als Token liefern
				for (int i = 0; i < 1024; i++) {
				int inChar = input();

					if (inChar == '\n') {
						unput ('\n');
						break;
					}
					if (inChar == '\032') 
						inChar = ' ';
					if (inChar != '\r') 
						InString[i] = inChar;
					else
						i--;
				}
				InString[i] = '\0';
			// Token generieren
			char *cptr = InString;
			char *pInBuff;
			// fuehrende Spaces ueberspringen
				while (isspace (*cptr)) cptr++;
				if (*cptr == '\'') cptr++;
			// evtl abschliessende Spaces beruecksichtigen
				if ((pInBuff = strchr (cptr, '\'')) != NULL)
					*pInBuff = '\0';
				if ((pInBuff = strchr (cptr, '\r')) != NULL)
					*pInBuff = '\0';
				pInBuff = new char [strlen(cptr) +1];
				strcpy (pInBuff, cptr);

			YYSTYPE tmpY (pInBuff, YYSTYPE :: YYString, yylineno);

				(*pyylval) = tmpY;
				return NAMSATZ;
			}
	YY_BREAK
case 27:
{	// dBase-Ankopplung: Rest der Zeile als Token liefern
			int len = 0;

				for (int i = 0; i < 1024; i++) {
				int inChar = input();

					if (inChar == '\r')
						break;
					if (inChar == '\032')
						inChar = ' ';
					InString [i] = inChar;
				}
				InString[i] = '\0';
				char *pInBuff = InString;
				while (pInBuff++ && *pInBuff == ' ')
					;
				if (*pInBuff) 
					memmove (InString, pInBuff,
						 len = strlen (pInBuff));
				pInBuff = new char [strlen(InString) +1];
				strcpy (pInBuff, InString);
				pInBuff[len] = '\0';

			YYSTYPE tmpY (pInBuff, YYSTYPE :: YYString, yylineno);

				(*pyylval) = tmpY;
				return POINTER;
			}
	YY_BREAK
case 28:
{	// dBase-Ankopplung: Rest der Zeile als Token liefern
				for (int i = 0; i < 1024; i++) {
				int inChar = input();

					if (inChar == '\r')
						break;
					if (inChar == '\032')
						inChar = ' ';
					InString [i] = inChar;
				}
				InString[i] = '\0';
				char *pInBuff = InString;
				while (pInBuff++ && *pInBuff == ' ')
					;
				if (*pInBuff) 
					memmove (InString, pInBuff,
						 strlen (pInBuff));
				pInBuff = new char [strlen(InString) +1];
				strcpy (pInBuff, InString);

			YYSTYPE tmpY (pInBuff, YYSTYPE :: YYString, yylineno);

				(*pyylval) = tmpY;
				return CODESATZ;
			}
	YY_BREAK
case 29:
{
				if (c_flag) // Kommentar weiterleiten
					fprintf (yyout, "; ");	 
				comment ("\n", c_flag); 	/* Kommentar */
				yylineno++;
			}
	YY_BREAK
case 30:
{	// Rest der Zeile einlesen und als Token liefern
				for (int i = 0; i < 1024; i++) {
				int inChar = input();

					if (inChar == '\n') {
						unput ('\n');
						break;
					}
					if (inChar == '\032') 
						inChar = ' ';
					if (inChar != '\r') 
						InString[i] = inChar;
					else
						i--;	// Index koorigieren
				}
				InString[i] = '\0';
			// Token generieren
			char *cptr = InString;
			char *pInBuff;
			// fuehrende Spaces ueberspringen
				while (isspace (*cptr)) cptr++;
				if (*cptr == '\'') cptr++;
			// evtl abschliessende Spaces beruecksichtigen
				if ((pInBuff = strchr (cptr, '\r')) != NULL)
					*pInBuff = '\0';
				if ((pInBuff = strchr (cptr, '\'')) != NULL)
					*pInBuff = '\0';
				pInBuff = new char [strlen(cptr) +1];
				strcpy (pInBuff, cptr);

			YYSTYPE tmpY (pInBuff, YYSTYPE :: YYString, yylineno);

				(*pyylval) = tmpY;
				return TXTSATZ;
			}
	YY_BREAK
case 31:
{	// sonstiger SatzTyp
			// alles bis zum ZeilenEnde ignorieren
				comment ("\n", FALSE);	/* als Kommentar behandeln*/
				yylineno++;
			}
	YY_BREAK
case 32:
{	// nichts machen, nur Zustand merken
				BEGIN HStufe;
			}
	YY_BREAK
case 33:
case 34:
{
			// Stackelement setzen (ZeilenNummer)
			YYSTYPE tmpY (NULL, YYSTYPE :: YYUnknown, yylineno);

				(*pyylval) = tmpY;
				if (*yytext == '/') BEGIN EnumHex;
				return (*yytext);
			}
	YY_BREAK
case 35:
{
			/* Integer - StufenNummer */
				BEGIN 0;
			long *inVal = new long (atol (yytext));
			YYSTYPE tmpY (inVal, YYSTYPE :: YYLong, yylineno);

				(*pyylval) = tmpY;
				if (*inVal == 1) {
				int tmpVal = SatzTyp;

					SatzTyp = 0;
					switch (tmpVal) {
					case PUNKT:
						return PUNKT1;
					case PUNKTKOORD:
						return PUNKTKOORD1;
					case LINIE:
						return LINIE1;
					case FLAECHE:
						return FLAECHE1;
					case BOGEN:
						return BOGEN1;
					case KREIS:
						return KREIS1;
					case POLYGON:
						return POLYGON1;
					case T_TEXT:
						return TEXT1;
					case SYMBOL:
						return SYMBOL1;
					default:
						return tmpVal;
					}
				} else {
				int tmpVal = SatzTyp;

					SatzTyp = 0;
					return tmpVal;
				}
						}
	YY_BREAK
case 36:
{
			double *ptmpD = new double (ReadSicadFloat (yytext+1)); 
			YYSTYPE tmpY (ptmpD, YYSTYPE :: YYDouble, yylineno);

				(*pyylval) = tmpY;
				return SICADREAL;
			}
	YY_BREAK
case 37:
{
						/* Integer */
			long *inVal = new long (atol (yytext));
			YYSTYPE tmpY (inVal, YYSTYPE :: YYLong, yylineno);

				BEGIN 0;
				(*pyylval) = tmpY;
							return (INTEGER);
						}
	YY_BREAK
case 38:
{
			long *inVal = new long (xtol (yytext));
			YYSTYPE tmpY (inVal, YYSTYPE :: YYLong, yylineno);

				BEGIN 0;
				(*pyylval) = tmpY;
				return INTEGER;
			}
	YY_BREAK
case 39:
case 40:
case 41:
{
						/* Real Number */
			double *inVal = new double (atof (yytext));
			YYSTYPE tmpY (inVal, YYSTYPE :: YYDouble, yylineno);

				(*pyylval) = tmpY;
							return (ASCIIREAL);
						}
	YY_BREAK
case 42:
{
			int i;
						/* ist ID ein reserviertes Wort ? */
							for (i = 0; keywords[i].lx ; i++) {
									if (!strcmp (keywords[i].id, yytext))
											break;
							}
							if (keywords[i].lx) {	/* ID ist Schluesselwort */
				char *inVal = new char [strlen(yytext)+1];
					strcpy (inVal, yytext);
							YYSTYPE tmpY (inVal, YYSTYPE :: YYString, yylineno);

					(*pyylval) = tmpY;
									return (keywords[i].lx);
							}
						/* ID ist sonstiger TextString */
			char *cptr = yytext;
			char *inVal;

			// fuehrende Spaces ueberspringen
				while (isspace (*cptr)) cptr++;
			// evtl abschliessende Spaces beruecksichtigen
				if ((inVal = strchr (cptr+1, '\'')) != NULL)
					*inVal = '\0';
				if ((inVal = strchr (cptr, '\r')) != NULL)
					*inVal = '\0';
				inVal = new char [strlen(cptr) +1];
				strcpy (inVal, cptr);

			YYSTYPE tmpY (inVal, YYSTYPE :: YYString, yylineno);

				(*pyylval) = tmpY;
								return (IDENT);
						}
	YY_BREAK
case 43:
case 44:
{
			/* TextString */
						register char *cptr = yytext;

				if (*yytext == '\'') cptr++;
				else while (isspace (*cptr)) cptr++;
 
			char *inVal = new char [strlen(cptr)+1];
				
							strcpy (inVal, cptr);
							if ((cptr = strchr (inVal, '\'')) != NULL)
									*cptr = '\0';

			YYSTYPE tmpY (inVal, YYSTYPE :: YYString, yylineno);

				(*pyylval) = tmpY;
							return (IDENT);
			}
	YY_BREAK
case 45:
{
				++yylineno;
				return '\n';
			}
	YY_BREAK
case 46:
;	/* ignore whites */
	YY_BREAK
case 47:
;	/* ignore */
	YY_BREAK
case 48:
YY_DEFAULT_ACTION;
	YY_BREAK

    case YY_NEW_FILE:
      break;
    case YY_END_TOK:
      return (YY_END_TOK);
    default:
      YY_FATAL_ERROR("fatal pclex scanner internal error");
    }

get_next_token:
    YY_DO_BEFORE_SCAN

    yy_curst = yy_start;

    if (yy_ch_buf[yy_c_buf_p] == '\n')
      ++yy_curst;

    yy_b_buf_p = yy_c_buf_p + 1;

    do {
      if (yy_c_buf_p == yy_e_buf_p) {
	if (yy_e_buf_p >= YY_BUF_LIM) {
	  yy_n_chars = yy_e_buf_p - yy_b_buf_p;

	  if (yy_n_chars >= 0) {
	    for (yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii) {
	      yy_buf_pos = yy_b_buf_p + yy_iii;
	      yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
	      yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
	    }
	  }

	  yy_b_buf_p = 0;
	  yy_e_buf_p = yy_n_chars;

	  if (yy_e_buf_p >= YY_BUF_LIM)
	    YY_FATAL_ERROR("pclex input buffer overflowed");

	    yy_c_buf_p = yy_e_buf_p;
	  } else if (yy_saw_eof) {
saweof:		
	  if (yy_b_buf_p <= yy_e_buf_p)
	    break;
	  if (yywrap())
	    yy_act = YY_END_TOK;
	  else {
	    YY_INIT;
	    yy_act = YY_NEW_FILE;
	  }
	  goto do_action;
	}

	YY_INPUT((yy_ch_buf + yy_c_buf_p + 1), yy_n_chars, YY_MAX_LINE);

	if (yy_n_chars == YY_NULL) {
	  if (yy_saw_eof)
	    YY_FATAL_ERROR("pclex scanner saw EOF twice - shouldn't happen");
	  yy_saw_eof = 1;
	  goto saweof;
	}

	yy_e_buf_p += yy_n_chars;
      }

      ++yy_c_buf_p;
      yy_sym = yy_ch_buf[yy_c_buf_p];

      while (c[b[yy_curst] + yy_sym] != yy_curst)
	yy_curst = d[yy_curst];

      yy_curst = n[b[yy_curst] + yy_sym];
      yy_st_buf[yy_c_buf_p] = yy_curst;

    } while (b[yy_curst] != YY_JAM_BASE);

    if (yy_c_buf_p >= yy_b_buf_p) {
      yy_curst = yy_st_buf[yy_c_buf_p];
      yy_lp = l[yy_curst];

find_rule:
      for ( ; ; ) {
	if (yy_lp && yy_lp < l[yy_curst + 1]) {
	  yy_act = a[yy_lp];
	  goto do_action;
	}

	if (--yy_c_buf_p < yy_b_buf_p)
	  break;

	yy_curst = yy_st_buf[yy_c_buf_p];
	yy_lp = l[yy_curst];
      }
    }
    ++yy_c_buf_p;

    yy_act = YY_DO_DEFAULT;
  }
}


// HexZahl konvertieren
long xtol (char *pInBuff) {
long InVal = 0;

	while (*pInBuff) {
		if (!isascii (*pInBuff)) 
		// Fehler
			return 0;
	// Konvertierung
		if (islower (*pInBuff)) 
			*pInBuff = toupper (*pInBuff);
		if (isdigit (*pInBuff))
			InVal += InVal * 16 + *pInBuff - '0';
		else if ((*pInBuff >= 'A') && (*pInBuff <= 'F'))
			InVal += InVal * 16 + *pInBuff - 'A' + 10;
		pInBuff++;	// nächstes Zeichen
	}

return InVal;
}

// Kommentar ueberlesen 
void comment (char *mat, int Flag) {

	register int c = 1;
	register char *cp = mat;
	int lno = yylineno;

	while (*cp && c != 0) {
		if ((c = input ()) != *cp++)
			cp = mat;
		if (Flag && c) 
			fputc (c, yyout);	// Kommentar weiterleiten
	}
	if (c == 0) {
		yylineno = lno;
		r_abort ("EOF im Kommentar gelesen");
	}
}

/* Parser Syntaxfehler */
void /*_cdecl*/ yyerror (const char *s) 
{
	r_error ((char *)s, yylineno);
}


/* Formatdefinitionsfehler */
void r_error (char *s, int ln) {
char ErrOut[256];

		++tot_errs;
	sprintf (ErrOut, "\nZeile %d: %s, aktuelles Token: %s\n", ln, s, yytext);
	fputs (ErrOut, stderr);
}


/* Schwerwiegender Formatdefinitionsfehler: Abbruch */
void r_abort (char *s) {
char ErrOut[256];

	sprintf (ErrOut, "Zeile %d: Abbruch - %s", yylineno, s);
	fputs (ErrOut, stderr);
	abort();	/* Abbrechen des Compilerlaufes */
}

// nächste Eingabedatei eröffnen
extern char *fnin[];
extern int cntInput;
extern int wasInput;

int yywrap (void) {

	yylineno = 1;
	if (wasInput < cntInput)
		return ascii_open (wasInput);	// nächstes File öffnen

return 1;	// ansonsten beenden
}

#if 0
void allprint(char c) {
		extern FILE *yyout;
		switch(c){
				case '\n':
						fprintf(yyout,"\\n");
						break;
				case '\t':
						fprintf(yyout,"\\t");
						break;
				case '\b':
						fprintf(yyout,"\\b");
						break;
				case ' ':
						fprintf(yyout,"\\\bb");
						break;
				default:
						if(!printable(c))
								fprintf(yyout,"\\%-3o",c);
						else 
								putc(c,yyout);
						break;
				}
		return;
		}
void sprint(char *s) {
		while(*s)
				allprint(*s++);
		return;
		}
int printable(int c)
		{
		return(040 < c && c < 0177);
		}
#endif
