//NamedObjects.h
// Copyright (c) 1998 Valery Pryamikov.

// usage:
// look at NamedObjTableModule.h for how to include this file into your project.
//

// Step-by-step sample on how to use:
// dll COM Server:
// 1. Create an ATL dll project workspace;
// 2. Insert a new ATL simple object (Insert\New ATL object... Simple Object)
// 3. in stdafx.h update line 
//		extern CComModule _Module; 
//	 with 
//		#include "NamedObjTableModule.h"
//		extern CNamedObjTableModule _Module;
// 4. in the YourNewAtlProject.cpp file change line 
//		CComModule _Module;
//	 with
//		CNamedObjTableModule _Module;
// 5. in stdafx.h just after line:
//		#include <atlcom.h>
//	 Insert a line 
//		#include "NamedObjects.h"
// 6. in the header file generated by step 2 insert line 
//		IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON(CYourNewAtlSimpleObject)
// 7. in the defintion of CYourNewAtlSimpleObject insert line
//		DECLARE_CLASSFACTORY_NAMED_SINGLETON(CYourNewAtlSimpleObject)
// That's all.
// Now you can use next statement in VB:
// set yourobject = GetObject("CLSID:XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX:!AnObjectName") 
// 'replase XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX with string representation of the CLSID of YourNewAtlSimpleObject.
// 
// if you need to use the name of the object anywhere in the code of the CYourNewAtlSimpleObject 
// than you have to insert next line in the definition of the CYourNewAtlSimpleObject class
// 		DECLARE_GET_OBJECT_NAME
// use result of the GetObjectName() function whenever you need this name.
//
//
// exe COM Server:
// 1. Create an ATL exe project workspace;
// 2. Insert a new ATL simple object (Insert\New ATL object... Simple Object)
// 3. in stdafx.h update line 
//		class CExeModule : public CComModule
//	 with 
//		#include "NamedObjTableModule.h"
//		class CExeModule : public CNamedObjTableModule
// 4. look at step 5 and following for dll COM server above
// ...

//
// Description:
//
// public definitions to use:
// IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON(class) macro
// IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON_EX(class, ParseDisplayNameClass) macro
// DECLARE_GET_OBJECT_NAME definition;
// DECLARE_CLASSFACTORY_NAMED_SINGLETON(class) macro
// HRESULT NamedObjectGetReference([[REFCLSID clsid],[void *pv]],LPCOLESTR name, REFIID riid, void**ppv) function.

// IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON/IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON_EX must be inserted just before definition of your COM (C++) class.
// Both those macro defines a custom class factory that uses CComFailCreator<E_FAIL>::CreateInstance for IClassFactory::CreateInstance, 
// but implements IOleItemContainer interface.
// For add-hooking your object to this custom class factory you must insert DECLARE_CLASSFACTORY_NAMED_SINGLETON in the definition of your class.
// if you are using IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON macro than ParseDisplayName method will be always creating Item Moniker with the 
// name that is a complete display name passed to ParseDisplayName (but without beginning "!" if there).
// It is quite enough if you need just a simple classMoniker!itemMoniker bindig functionality. 
// With IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON_EX you might adjust parsing of display name and objects creation policy to whatever you need 
// by redifining two virtual operators of ParseDisplayName class (see definition below).
// If you need to access object's name from your class methods you have to insert DECLARE_GET_OBJECT_NAME into your class definition, and 
// after you just can use GetObjectName() function for this.
// You may use NamedObjectGetReference function for retrieving (and creating new instance) of the named object from your module.
// if you used a CLSID as a first parameter to this function, than new object with will be automatically constructed if 
// objects table does not contains an object with requested name. 
// Parameter void *pv is used by IOleItemContainer interface (for passing IBindCtx pointer)
//
// You can to do whatever sophisticated ParseDisplayName you need by implementing a class inherited from ParseDisplayName 
// and using its name as a second parameter to the IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON_EX(class, ParseDisplayNameClass) macro.
// f.e you can add-hook to your custom moniker's ParseDisplayName by doing something like next:
//		class CYourMonikersParseDisplayName: public ParseDisplayName
//		{
//			HRESULT operator () (IBindCtx *pbc, LPCOLESTR pszDisplayName, ULONG *pchEaten, IMoniker **ppmkOut) {
//				return CYourMonikerClass::ParseDisplayName(pbc, pszDisplayName, pchEaten, ppmkOut);}
//			bool operator () (LPCOLESTR pszDisplayName, void *pv) {return true;}
//		};
//		IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON_EX(CYourNewAtlSimpleObject, CYourMonikersParseDisplayName)
//		...
//		STDMETHODIMP CYourMonikerClass::BindToObject(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppv) {
//			return NamedObjectGetReference(clsidOfTheNamedObject,pbc,mkDisplayName, riid, ppv);
//		}
//
//

#ifndef __NAMEDOBJECTS_H__
#define __NAMEDOBJECTS_H__

/////////////////////////////////////////////////////////////////////////////
//

#define IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON(cls) class cls; typedef CNamedObjectFactoryClass< cls > cls##_no_cfc;
#define IMPLEMENT_CLASSFACTORY_NAMED_SINGLETON_EX(cls,parsedn) class cls; class parsedn; typedef CNamedObjectFactoryClass< cls, parsedn > cls##_no_cfc;

#define DECLARE_GET_OBJECT_NAME() virtual LPCOLESTR GetObjectName() const {return NULL;}
#define DECLARE_CLASSFACTORY_NAMED_SINGLETON(cls) DECLARE_CLASSFACTORY_EX(cls##_no_cfc) \
	typedef CComFailCreator<E_FAIL>  _CreatorClass;

inline HRESULT NamedObjectGetReference(LPCOLESTR name, REFIID riid, void**ppv)
{
	return _Module.GetObjectReference(name, riid, ppv);
}

inline HRESULT NamedObjectGetReference(REFCLSID cslid, LPCOLESTR name, REFIID riid, void**ppv)
{
	return NamedObjectGetReference(cslid, NULL, name, riid, ppv);
}

inline HRESULT NamedObjectGetReference(REFCLSID cslid, void*pv, LPCOLESTR name, REFIID riid, void**ppv)
{
	CComPtr<INamedObjectFactory> pfactory;
	HRESULT hr = AtlModuleGetClassObject(&_Module, cslid, __uuidof(INamedObjectFactory), (void**)&pfactory);
	if (FAILED(hr)) return hr;
	return pfactory->GetNamedObject(name,pv,riid,ppv);
}

class ParseDisplayName
{
public:
	virtual HRESULT operator () (IBindCtx *pbc, LPCOLESTR pszDisplayName, ULONG *pchEaten, IMoniker **ppmkOut) = 0;
	//next one is called just before creation of the new *pszDisplayName named object. Return false to stop intialization.
	virtual bool operator () (LPCOLESTR pszDisplayName, void *pv) = 0;
};

/////////////////////////////////////////////////////////////////////////////
// Implementation

inline HRESULT _NamedObjectGetOrConstruct(LPCOLESTR name, void* pv, _NAMEDOBJECT_CREATORFUNC *pfnCreate, REFIID riid, void**ppv)
{
	return _Module.GetOrConstructNewReference(name, riid, ppv, pv, pfnCreate);
}

inline HRESULT _NamedObjectReleaseReference(LPCOLESTR name)
{
	return _Module.ReleaseObjectReference(name);
}

template<class T>
class CComNamedObject: public CComObject<T> 
{
protected:
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
public:
	CComNamedObject(LPCOLESTR szwName) {
		if (szwName) {
			m_szwName = (LPOLESTR)CoTaskMemAlloc((wcslen(szwName)+1)*sizeof(OLECHAR));
			if (m_szwName) wcscpy(m_szwName,szwName);
		} else m_szwName = NULL;
	}
	~CComNamedObject() {
		if (m_szwName) {
			_NamedObjectReleaseReference(m_szwName);
			CoTaskMemFree(m_szwName);
		}
	}
	LPCOLESTR GetObjectName() const {return m_szwName;}
private:
	LPOLESTR m_szwName;
};

class SimpleParseDisplayName: public ParseDisplayName
{
public:
	HRESULT operator () (IBindCtx *pbc, LPCOLESTR pszDisplayName, ULONG *pchEaten, IMoniker **ppmkOut) {
		if (!ppmkOut) return E_POINTER;
		*ppmkOut = NULL;
		ULONG dwSafeEaten;
		if (!pchEaten) pchEaten = &dwSafeEaten;
		*pchEaten = NULL;
		LPCOLESTR pdn = pszDisplayName;
		if (*pdn == L'!') pdn++;
		HRESULT hr = CreateItemMoniker(L"!",pdn,ppmkOut);
		if (SUCCEEDED(hr)) *pchEaten = wcslen(pszDisplayName);
		return hr;
	}
	bool operator () (LPCOLESTR pszDisplayName, void *pv) {return true;}
};

template< class T, class Parser = SimpleParseDisplayName >
class CNamedObjectFactoryClass:
    public CComObjectRootEx<CComMultiThreadModel>,
	public IClassFactory, 
	public INamedObjectFactory,
	public IOleItemContainer
{
public:
BEGIN_COM_MAP(CNamedObjectFactoryClass)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY_IID(__uuidof(INamedObjectFactory) ,INamedObjectFactory)
	COM_INTERFACE_ENTRY(IParseDisplayName)
	COM_INTERFACE_ENTRY(IOleContainer)
	COM_INTERFACE_ENTRY(IOleItemContainer)
END_COM_MAP()

protected:
// IClassFactory methods overrides 
	STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject) {
		_ASSERTE(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObject != NULL) {
			*ppvObject = NULL;
			// can't ask for anything other than IUnknown when aggregating
			_ASSERTE((pUnkOuter == NULL) || InlineIsEqualUnknown(riid));
			if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
				hRes = CLASS_E_NOAGGREGATION;
			else
				hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObject);
		}
		return hRes;
	}

	STDMETHODIMP LockServer(BOOL fLock) {
        if (fLock) _Module.Lock();
		else _Module.Unlock();
        return S_OK;
	}

protected:
//INamedObjectFactory overrides
	STDMETHODIMP GetNamedObject(LPCOLESTR name, void *pv, REFIID riid, void **ppv) {
		return _NamedObjectGetOrConstruct(name, pv, (_NAMEDOBJECT_CREATORFUNC *)CreateNamedInstance, riid, ppv);
	}

private:
	static HRESULT WINAPI CreateNamedInstance(LPCOLESTR name, void* pv, REFIID riid, LPVOID* ppv) {
		_ASSERTE(*ppv == NULL);
		if (!Parser()(name,pv)) return MK_E_NOOBJECT;
		HRESULT hRes = E_OUTOFMEMORY;
		CComNamedObject< T > *p = NULL;
		ATLTRY(p = new CComNamedObject< T >(name))
		if (p != NULL) {
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}

public:
// IParseDisplayName methods overrides
	STDMETHODIMP ParseDisplayName(IBindCtx *pbc, 
		LPOLESTR pszDisplayName, ULONG *pchEaten,
		IMoniker **ppmkOut) {return Parser()(pbc, pszDisplayName, pchEaten, ppmkOut);}

public:
// IOleContainer methods overrides
	STDMETHODIMP EnumObjects(DWORD grfFlags, IEnumUnknown **ppenum) {
		return E_NOTIMPL;
	}
	STDMETHODIMP LockContainer(BOOL fLock) {
        if (fLock) _Module.Lock();
		else _Module.Unlock();
        return S_OK;
	}

public:
// IOleItemContainer methods overrides
	STDMETHODIMP GetObject(LPOLESTR pszItem, DWORD dwSpeedNeeded, 
		IBindCtx *pbc, REFIID riid, void **ppv) {
		return GetNamedObject(pszItem, pbc, riid, ppv);
	}
	STDMETHODIMP GetObjectStorage(LPOLESTR pszItem, IBindCtx *pbc,
		REFIID riid, void **ppvStorage) {return E_NOTIMPL;}
	STDMETHODIMP IsRunning(LPOLESTR pszItem) {return S_OK;}

public:
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}

private:
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

///////////////////////////////////////////////////////////////////////////////
// Helper Funktion für GIT-Zugriff
inline IGlobalInterfaceTable *CNamedObjTableModule::CGITHelper::GIT() { return _Module.GIT(); }

#endif //__NAMEDOBJECTS_H__
