#define YY_DEFAULT_ACTION YY_FATAL_ERROR("flex scanner jammed");
/* A lexical scanner generated by pclex */

#define YY_END_TOK 0
#define YY_NEW_FILE -1
#define YY_DO_DEFAULT -2
#if !defined(BUFSIZ)
#if defined(__cplusplus)
extern "C" {
#endif
#include <stdio.h>
#if defined(__cplusplus)
}
#endif
#endif
#define F_BUFSIZ 128
#define YY_BUF_SIZE (F_BUFSIZ * 2)
#define YY_BUF_MAX (YY_BUF_SIZE - 1)
#ifndef YY_MAX_LINE
#define YY_MAX_LINE F_BUFSIZ
#endif
#define YY_BUF_LIM (YY_BUF_MAX - YY_MAX_LINE)
#define ECHO fputs(yytext, yyout)
#define YY_INPUT(buf,result,max_size) \
	memset(buf,'\0',max_size); \
	if (fgets(buf, max_size, yyin) != NULL) \
	    result = strlen(buf); \
	else if (!ferror(yyin)) \
	    result = YY_NULL; \
	else \
	    YY_FATAL_ERROR("fgets() in pclex scanner failed");
#define YY_NULL 0
#define YY_OUTPUT(c) fputc(c, yyout);
#define YY_FATAL_ERROR(msg) \
	{ \
	fputs(msg, stderr); \
	putc('\n', stderr); \
	exit(1); \
	}
#define YY_FIRST_CHAR yy_ch_buf[yy_b_buf_p]
#define yywrap() 1
#define BEGIN yy_start = 1 +
#define YY_SET_BOL(array,pos) array[pos - 1] = '\n';
#define YY_DECL int yylex()
#define yyless(n) \
	{ \
	YY_DO_BEFORE_SCAN; \
	yy_c_buf_p = yy_b_buf_p + n - 1; \
	YY_DO_BEFORE_ACTION; \
	}
#define YY_BREAK break;
#define YY_INIT \
	{ \
	yyleng = yy_c_buf_p = yy_e_buf_p = 0; \
	yy_hold_char = yy_ch_buf[yy_c_buf_p] = '\n'; \
	yytext = &yy_ch_buf[yy_c_buf_p]; \
	yy_saw_eof = 0; \
	}
#define YY_LENG (yy_c_buf_p - yy_b_buf_p + 1)
#define YY_DO_BEFORE_SCAN \
	yytext[yyleng] = yy_hold_char;
#define YY_DO_BEFORE_ACTION \
	yytext = &yy_ch_buf[yy_b_buf_p]; \
	yyleng = YY_LENG; \
	yy_hold_char = yytext[yyleng]; \
	yytext[yyleng] = '\0';
#define REJECT \
        { \
	YY_DO_BEFORE_SCAN; \
	yy_c_buf_p = yy_full_match; \
        ++yy_lp; \
        goto find_rule; \
        }

static int input(void);
static void unput(char);

#define __INITIAL 0

// Scanner fuer ASCPUT (Analyse des ASCII-Formates) ---------------------------
// File: ASCPARS.LX

#include "ascimpp.hpp"

#if defined(_MSC_VER)
#pragma warning (disable:4102)	// unreferenced label
#endif 

#include <ctype.h>

#include "ascpars.h"
#include "ytab.h"

int yylineno = 0;

struct keyentry {	// Tabelleneintrag fuer reservierte Worte
	int  lx;
	char *id;
};

// reservierte Worte, die vom Scanner identifiziert werden
struct keyentry keywords[] = {
	{       T_OFFSET, "OFFSET"      },
	{       T_SCALE, "SCALE"        },
	{	T_ENTRYROSYS, "ENTRYROSYS"	},
	{	T_ENTRYRO, "ENTRYRO"	},
	{	T_ENTRYSYS, "ENTRYSYS"	},
	{	T_ENTRY, "ENTRY"	},
	{	T_PBDNAME, "PBDNAME"	},
	{       0, NULL                 },
};

#define merkmal 2
#define textmerkmal 4
#define Control 6
#define Relation 8
#define YY_JAM 73
#define YY_JAM_BASE 700
static char a[179] =
    {   0,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       36,   37,   34,   36,   37,   23,   37,   24,   36,   37,
       25,   36,   37,   36,   37,   36,   37,   27,   36,   37,
       27,   36,   37,   35,   36,   37,   22,   36,   37,    8,
       35,   36,   37,   18,   35,   36,   37,    6,   35,   36,
       37,   16,   35,   36,   37,    2,   35,   36,   37,    7,
       35,   36,   37,    5,   35,   36,   37,    9,   35,   36,
       37,   17,   35,   36,   37,    3,   35,   36,   37,   10,
       35,   36,   37,    1,   35,   36,   37,   11,   35,   36,
       37,   15,   35,   36,   37,    4,   35,   36,   37,   33,

       35,   36,   37,   32,   35,   36,   37,   31,   35,   36,
       37,    2,   32,   35,   36,   37,    9,   31,   35,   36,
       37,   20,   35,   36,   37,   21,   35,   36,   37,   19,
       35,   36,   37,    9,   21,   35,   36,   37,   14,   35,
       36,   37,   12,   35,   36,   37,   13,   35,   36,   37,
        8,   14,   35,   36,   37,    5,   12,   35,   36,   37,
       13,   17,   35,   36,   37,   34,   27,   29,   28,   35,
       28,   29,   30,   26,   29,   28,   28,   29
    } ;

static short int l[75] =
    {   0,
       -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,   -2,
       11,   13,   16,   18,   21,   24,   26,   28,   31,   34,
       37,   40,   44,   48,   52,   56,   60,   64,   68,   72,
       76,   80,   84,   88,   92,   96,  100,  104,  108,  112,
      117,  122,  126,  130,  134,  139,  143,  147,  151,  156,
      161,  166,  167,  167,  168,  169,  170,  170,  170,  171,
      171,  173,  173,  173,  174,  175,  175,  176,  176,  176,
      177,  177,  179,  179
    } ;

static short int b[76] =
    {   0,
        0,   69,   82,   95,    0,  117,  130,  152,  130,  174,
      700,  125,  700,  700,  700,  214,  224,  236,  260,    0,
      700,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,  141,  246,  294,  316,  350,  377,    0,    0,  392,
      404,  426,  326,  436,    0,  446,  458,  473,  483,  493,
      503,  513,  700,  523,  598
    } ;

static short int d[76] =
    {   0,
       73,    1,    1,    1,    1,    1,    1,    1,    1,    1,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   74,
       73,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   73,   73,   73,   73,   73,   73,   75,   74,   73,
       73,   73,   73,   73,   75,   73,   73,   73,   73,   73,
       73,   73,-32767,   73,   73
    } ;

static short int n[828] =
    {   0,
       11,   11,   11,   11,   11,   11,   11,   11,   12,   13,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
       11,   12,   11,   14,   11,   11,   11,   11,   15,   11,
       11,   11,   16,   11,   16,   17,   11,   18,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   11,   11,   11,
       11,   11,   11,   11,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       11,   11,   11,   11,   20,   11,   20,   20,   20,   20,

       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   20,   20,   20,   20,   20,   20,   20,   20,
       20,   20,   11,   11,   11,   11,   11,   21,   73,   73,
       73,   73,   73,   52,   22,   23,   24,   25,   26,   27,
       28,   29,   73,   30,   31,   32,   37,   73,   33,   52,
       34,   38,   35,   21,   39,   36,   52,   73,   73,   37,
       22,   23,   24,   25,   40,   27,   28,   41,   73,   30,
       31,   32,   52,   73,   33,   21,   34,   73,   35,   73,
       73,   36,   22,   23,   24,   25,   26,   27,   28,   29,
       73,   30,   31,   32,   42,   46,   33,   73,   34,   73,

       35,   47,   43,   36,   48,   73,   73,   73,   73,   73,
       21,   73,   73,   73,   73,   44,   42,   22,   23,   24,
       25,   26,   27,   28,   45,   73,   30,   31,   32,   73,
       73,   33,   21,   34,   73,   35,   73,   44,   36,   49,
       23,   24,   25,   26,   27,   50,   29,   73,   51,   31,
       32,   73,   73,   33,   73,   34,   73,   35,   73,   53,
       36,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   55,   55,   55,   55,   55,   55,   55,   55,   55,
       55,   56,   73,   54,   54,   54,   54,   54,   54,   54,
       54,   54,   54,   55,   55,   55,   55,   55,   55,   55,

       55,   55,   55,   57,   57,   56,   73,   54,   54,   54,
       54,   54,   54,   54,   54,   54,   54,   73,   73,   73,
       73,   73,   73,   58,   73,   73,   73,   57,   57,   73,
       73,   73,   73,   73,   73,   57,   57,   73,   73,   56,
       73,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,   73,   73,   73,   73,   58,   73,   73,   73,   57,
       57,   57,   57,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   64,   64,   64,   64,   64,   64,   64,
       64,   64,   64,   60,   60,   73,   73,   73,   73,   73,
       73,   73,   73,   57,   57,   73,   73,   61,   61,   61,

       61,   61,   61,   61,   61,   61,   61,   73,   73,   73,
       73,   73,   73,   73,   73,   60,   60,   62,   62,   63,
       73,   63,   73,   73,   64,   64,   64,   64,   64,   64,
       64,   64,   64,   64,   66,   73,   66,   73,   73,   67,
       67,   67,   67,   67,   67,   67,   67,   67,   67,   62,
       62,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,   73,   73,   73,   73,   73,   73,   73,   69,   73,
       69,   68,   68,   70,   70,   70,   70,   70,   70,   70,
       70,   70,   70,   64,   64,   64,   64,   64,   64,   64,
       64,   64,   64,   67,   67,   67,   67,   67,   67,   67,

       67,   67,   67,   68,   68,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   71,   73,   71,   73,   73,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       73,   73,   73,   73,   73,   73,   73,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,

       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   73,   73,   73,   73,   59,   73,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   59,   59,   59,   59,   59,
       59,   59,   59,   59,   59,   65,   65,   65,   65,   65,
       65,   65,   65,   65,   65,   73,   73,   73,   73,   73,
       73,   73,   65,   65,   65,   65,   65,   65,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   65,   65,   65,   65,   65,   65,

       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,

       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73
    } ;

static short int c[828] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    2,    0,    0,
        0,    0,    0,   12,    2,    2,    2,    2,    2,    2,
        2,    2,    0,    2,    2,    2,    3,    0,    2,   52,
        2,    3,    2,    4,    3,    2,   12,    0,    0,    4,
        4,    4,    4,    4,    4,    4,    4,    4,    0,    4,
        4,    4,   52,    0,    4,    6,    4,    0,    4,    0,
        0,    4,    6,    6,    6,    6,    6,    6,    6,    6,
        0,    6,    6,    6,    7,    9,    6,    0,    6,    0,

        6,    9,    7,    6,    9,    0,    0,    0,    0,    0,
        8,    0,    0,    0,    0,    7,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    0,    8,    8,    8,    0,
        0,    8,   10,    8,    0,    8,    0,    8,    8,   10,
       10,   10,   10,   10,   10,   10,   10,    0,   10,   10,
       10,    0,    0,   10,    0,   10,    0,   10,    0,   16,
       10,   16,   16,   16,   16,   16,   16,   16,   16,   16,
       16,   17,   17,   17,   17,   17,   17,   17,   17,   17,
       17,   18,    0,   18,   18,   18,   18,   18,   18,   18,
       18,   18,   18,   53,   53,   53,   53,   53,   53,   53,

       53,   53,   53,   18,   18,   19,    0,   19,   19,   19,
       19,   19,   19,   19,   19,   19,   19,    0,    0,    0,
        0,    0,    0,   18,    0,    0,    0,   19,   19,    0,
        0,    0,    0,    0,    0,   18,   18,    0,    0,   54,
        0,   54,   54,   54,   54,   54,   54,   54,   54,   54,
       54,    0,    0,    0,    0,   18,    0,    0,    0,   19,
       19,   54,   54,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   55,   63,   63,   63,   63,   63,   63,   63,
       63,   63,   63,   55,   55,    0,    0,    0,    0,    0,
        0,    0,    0,   54,   54,    0,    0,   56,   56,   56,

       56,   56,   56,   56,   56,   56,   56,    0,    0,    0,
        0,    0,    0,    0,    0,   55,   55,   56,   56,   57,
        0,   57,    0,    0,   57,   57,   57,   57,   57,   57,
       57,   57,   57,   57,   60,    0,   60,    0,    0,   60,
       60,   60,   60,   60,   60,   60,   60,   60,   60,   56,
       56,   61,   61,   61,   61,   61,   61,   61,   61,   61,
       61,    0,    0,    0,    0,    0,    0,    0,   62,    0,
       62,   61,   61,   62,   62,   62,   62,   62,   62,   62,
       62,   62,   62,   64,   64,   64,   64,   64,   64,   64,
       64,   64,   64,   66,   66,   66,   66,   66,   66,   66,

       66,   66,   66,   61,   61,   67,   67,   67,   67,   67,
       67,   67,   67,   67,   67,   68,    0,   68,    0,    0,
       68,   68,   68,   68,   68,   68,   68,   68,   68,   68,
       69,   69,   69,   69,   69,   69,   69,   69,   69,   69,
       70,   70,   70,   70,   70,   70,   70,   70,   70,   70,
       71,   71,   71,   71,   71,   71,   71,   71,   71,   71,
       72,   72,   72,   72,   72,   72,   72,   72,   72,   72,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
        0,    0,    0,    0,    0,    0,    0,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,

       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,    0,    0,    0,    0,   74,    0,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   74,   74,   74,   74,   74,
       74,   74,   74,   74,   74,   75,   75,   75,   75,   75,
       75,   75,   75,   75,   75,    0,    0,    0,    0,    0,
        0,    0,   75,   75,   75,   75,   75,   75,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   75,   75,   75,   75,   75,   75,

       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,

       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73,   73,   73,   73,
       73,   73,   73,   73,   73,   73,   73
    } ;


FILE *yyin = stdin, *yyout = stdout;
static int yy_start, yy_b_buf_p, yy_c_buf_p, yy_e_buf_p;
static int yy_saw_eof = 1, yy_init = 1;
static char yy_ch_buf[YY_BUF_SIZE + 1];
static int yy_st_buf[YY_BUF_SIZE];
static char yy_hold_char;
char *yytext;
int yyleng;

static int input(void)
{
  int c;

  YY_DO_BEFORE_SCAN
  if (yy_c_buf_p == yy_e_buf_p) {
    int yy_n_chars;

    if (yy_saw_eof) {
      if (yywrap())
	 return (EOF);

      YY_INIT;
    }

    yy_b_buf_p = 0;
    YY_INPUT(yy_ch_buf, yy_n_chars, YY_MAX_LINE);

    if (yy_n_chars == YY_NULL) {
      yy_saw_eof = 1;

      if (yywrap())
	return (EOF);

      YY_INIT;
      return (input());
    }

    yy_c_buf_p = -1;
    yy_e_buf_p = yy_n_chars - 1;
  }

  c = yy_ch_buf[++yy_c_buf_p];

  YY_DO_BEFORE_ACTION;

  return (c);
}


static void unput(char c)
{
    YY_DO_BEFORE_SCAN;

    if (yy_c_buf_p == 0) {
	register int i;
	register int yy_buf_pos = YY_BUF_MAX;

	for (i = yy_e_buf_p; i >= yy_c_buf_p; --i) {
	    yy_ch_buf[yy_buf_pos] = yy_ch_buf[i];
	    yy_st_buf[yy_buf_pos] = yy_st_buf[i];
	    --yy_buf_pos;
	}

	yy_c_buf_p = YY_BUF_MAX - yy_e_buf_p;
	yy_e_buf_p = YY_BUF_MAX;
    }

    if (yy_c_buf_p <= 0)
	YY_FATAL_ERROR("pclex scanner push-back overflow");

    if (yy_c_buf_p >= yy_b_buf_p && yy_ch_buf[yy_c_buf_p] == '\n')
	yy_ch_buf[yy_c_buf_p - 1] = '\n';

    yy_ch_buf[yy_c_buf_p--] = c;

    YY_DO_BEFORE_ACTION;
}


YY_DECL
{
  register int yy_curst;
  register char yy_sym;
  int yy_n_chars, yy_lp, yy_iii, yy_buf_pos, yy_act, yy_full_match;




  if (yy_init) {
    YY_INIT;
    yy_start = 1;
    yy_init = 0;
  }
  goto get_next_token;

do_action:
  yy_full_match = yy_c_buf_p;

  for ( ; ; )	{
    YY_DO_BEFORE_ACTION

    switch (yy_act) {
case 1:
{       /* Identifikatorsatz Punkt */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return (T_PSATZ);
			}
	YY_BREAK
case 2:
{       /* Identifikatorsatz Flaeche */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return (T_FSATZ);
			}
	YY_BREAK
case 3:
{       /* Identifikatorsatz Linie */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return (T_LSATZ);
			}
	YY_BREAK
case 4:
{       /* Wertesatz (Merkmalswerte, Relationen) */
				yylval.numtok.num_line = yylineno;
				return (T_WSATZ);
			}
	YY_BREAK
case 5:
{       /* Kopfsatz */
				BEGIN 0;
				read_string (yylval.strtok.string);
				yylval.strtok.str_line = yylineno;
				return (T_HSATZ);
			}
	YY_BREAK
case 6:
{       /* Beschreibungssatz */
				BEGIN 0;
				yylval.strtok.str_line = yylineno;
				return (T_DSATZ);
			}
	YY_BREAK
case 7:
{       /* Geometriesatz */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return (T_GSATZ);
			}
	YY_BREAK
case 8:
{	/* BegleitObjektSatz */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return T_BSATZ;
			}
	YY_BREAK
case 9:
{	/* Text eines Begleitobjektes */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return T_ISATZ;
			}
	YY_BREAK
case 10:
{       /* Merkmalssatz */
				BEGIN merkmal;
				yylval.numtok.num_line = yylineno;
				return (T_MSATZ);
			}
	YY_BREAK
case 11:
{       /* Relationssatz */
				BEGIN Relation;
				yylval.numtok.num_line = yylineno;
				return (T_RSATZ);
			}
	YY_BREAK
case 12:
{	/* gleichrangige Relation */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return T_HRELSATZ;
			}
	YY_BREAK
case 13:
{	/* Komplexrelation */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return T_KRELSATZ;
			}
	YY_BREAK
case 14:
{	/* Begleitobjektrelation */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return T_BRELSATZ;
			}
	YY_BREAK
case 15:
{       /* Trennsatz */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return (T_TSATZ);
			}
	YY_BREAK
case 16:
{       /* EndeSatz */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return (T_ESATZ);
			}
	YY_BREAK
case 17:
{       /* KomplexObjekt */
				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				return T_KOSATZ;
			}
	YY_BREAK
case 18:
{	/* SteuerSatz */
				BEGIN Control;
				yylval.numtok.num_line = yylineno;
				return T_CSATZ;
			}
	YY_BREAK
case 19:
{	/* VerschnittDirektive */
			char NextIn;

				BEGIN 0;
				yylval.numtok.num_line = yylineno;
				NextIn = input();
				while (isspace(NextIn)) 
					NextIn = input();
				yylval.numtok.intnum = (NextIn == '-') ? true : false;
				return T_VSATZ;
			}
	YY_BREAK
case 20:
{		/* Abgleichdirektive */
			char NextIn;

				BEGIN 0;
				yylval.strtok.str_line = yylineno;
				NextIn = input();
				while (isspace(NextIn)) 
					NextIn = input();

			char *cptr = yylval.strtok.string;

				while (!isspace(NextIn)) {
					if (EOF == NextIn)
						break;
					*cptr++ = NextIn;
					NextIn = input();
				}

				unput(NextIn);
				*cptr = '\0';
				return T_ABGLEICH;
			}
	YY_BREAK
case 21:
{		/* Abgleichdirektive */
				yylval.numtok.num_line = yylineno;
				return T_IMPORT;
			}
	YY_BREAK
case 22:
{       /* Kommentarsatz */
				BEGIN 0;
				read_string (yylval.strtok.string);
				yylval.strtok.str_line = yylineno;
				return (T_KSATZ);
			}
	YY_BREAK
case 23:
{       /* Zeilen zaehlen */
				yylval.numtok.num_line = yylineno++;
				return ('\n');
			}
	YY_BREAK
case 24:
case 25:
{
			int scope_char = yytext[0];
			int inchar;
			char *cptr = yylval.strtok.string;
			char *pBuff = cptr;

				BEGIN 0;

				inchar = input();
				while (inchar != scope_char) {
					if (EOF == inchar)
						break;
					*cptr++ = inchar;
					inchar = input();
				}
				*cptr = '\0';

				OemToAnsi (pBuff, pBuff);		// --> Windows Zeichensatz
				yylval.strtok.str_line = yylineno;
				return (T_STRING);
			}
	YY_BREAK
case 26:
{       /* HexIntegerzahl */
				yylval.numtok.intnum = strtoul (yytext, NULL, 16);
				yylval.numtok.num_line = yylineno;
				return (T_HEXINTEGER);
			}
	YY_BREAK
case 27:
{       /* Integerzahl */
				yylval.numtok.intnum = atol (yytext);
				yylval.numtok.num_line = yylineno;
				return (T_INTEGER);
			}
	YY_BREAK
case 28:
case 29:
case 30:
{       /* Floatpointzahl */
				yylval.flttok.fltnum = atof (yytext);
				yylval.flttok.flt_line = yylineno;
				return (T_FLOAT);
			}
	YY_BREAK
case 31:
case 32:
{
				BEGIN 0;
				yylval.strtok.str_line = yylineno;
				return (*yytext);
			}
	YY_BREAK
case 33:
{
				BEGIN textmerkmal;
				yylval.strtok.str_line = yylineno;
				return ('A');
			}
	YY_BREAK
case 34:
;               /* ignorieren */
	YY_BREAK
case 35:
{		/* Keyword */
			register int i;

				strncpy (yylval.strtok.string, yytext, NAMELEN);
				strupr (yylval.strtok.string);
		
			/* ist ID ein reserviertes Wort ? */
				for (i = 0; keywords[i].lx ; i++) {
					if (!strcmp (keywords[i].id, yylval.strtok.string))
						break;
				}
				if (keywords[i].lx) {   /* ID ist Schluesselwort */
					yylval.strtok.str_line = yylineno;
					return (keywords[i].lx);
				} 
				else {          /* kein Keyword --> Fehler */
				char *pBuff = yylval.strtok.string;

					OemToAnsi (pBuff, pBuff);
					yylval.numtok.num_line = yylineno;
					return (T_IDENT);
				}
			}
	YY_BREAK
case 36:
;       /* alles andere schlicht ignorieren */
	YY_BREAK
case 37:
YY_DEFAULT_ACTION;
	YY_BREAK

    case YY_NEW_FILE:
      break;
    case YY_END_TOK:
      return (YY_END_TOK);
    default:
      YY_FATAL_ERROR("fatal pclex scanner internal error");
    }

get_next_token:
    YY_DO_BEFORE_SCAN

    yy_curst = yy_start;

    if (yy_ch_buf[yy_c_buf_p] == '\n')
      ++yy_curst;

    yy_b_buf_p = yy_c_buf_p + 1;

    do {
      if (yy_c_buf_p == yy_e_buf_p) {
	if (yy_e_buf_p >= YY_BUF_LIM) {
	  yy_n_chars = yy_e_buf_p - yy_b_buf_p;

	  if (yy_n_chars >= 0) {
	    for (yy_iii = 0; yy_iii <= yy_n_chars; ++yy_iii) {
	      yy_buf_pos = yy_b_buf_p + yy_iii;
	      yy_ch_buf[yy_iii] = yy_ch_buf[yy_buf_pos];
	      yy_st_buf[yy_iii] = yy_st_buf[yy_buf_pos];
	    }
	  }

	  yy_b_buf_p = 0;
	  yy_e_buf_p = yy_n_chars;

	  if (yy_e_buf_p >= YY_BUF_LIM)
	    YY_FATAL_ERROR("pclex input buffer overflowed");

	    yy_c_buf_p = yy_e_buf_p;
	  } else if (yy_saw_eof) {
saweof:		
	  if (yy_b_buf_p <= yy_e_buf_p)
	    break;
	  if (yywrap())
	    yy_act = YY_END_TOK;
	  else {
	    YY_INIT;
	    yy_act = YY_NEW_FILE;
	  }
	  goto do_action;
	}

	YY_INPUT((yy_ch_buf + yy_c_buf_p + 1), yy_n_chars, YY_MAX_LINE);

	if (yy_n_chars == YY_NULL) {
	  if (yy_saw_eof)
	    YY_FATAL_ERROR("pclex scanner saw EOF twice - shouldn't happen");
	  yy_saw_eof = 1;
	  goto saweof;
	}

	yy_e_buf_p += yy_n_chars;
      }

      ++yy_c_buf_p;
      yy_sym = yy_ch_buf[yy_c_buf_p];

      while (c[b[yy_curst] + yy_sym] != yy_curst)
	yy_curst = d[yy_curst];

      yy_curst = n[b[yy_curst] + yy_sym];
      yy_st_buf[yy_c_buf_p] = yy_curst;

    } while (b[yy_curst] != YY_JAM_BASE);

    if (yy_c_buf_p >= yy_b_buf_p) {
      yy_curst = yy_st_buf[yy_c_buf_p];
      yy_lp = l[yy_curst];

find_rule:
      for ( ; ; ) {
	if (yy_lp && yy_lp < l[yy_curst + 1]) {
	  yy_act = a[yy_lp];
	  goto do_action;
	}

	if (--yy_c_buf_p < yy_b_buf_p)
	  break;

	yy_curst = yy_st_buf[yy_c_buf_p];
	yy_lp = l[yy_curst];
      }
    }
    ++yy_c_buf_p;

    yy_act = YY_DO_DEFAULT;
  }
}


char *read_string (char *cptr)
{
register char *cptr_old = cptr;

	while ((*cptr++ = input ()) != '\n')
		;
	*--cptr = '\0';
	
	OemToAnsi (cptr_old, cptr_old);		// --> Windows Zeichensatz

	unput ('\n');
	return (cptr_old);
}

void skip_lines (char *pattern) 
{
register int c;

/* Satz suchen, der mit Kennzeichen aus pattern beginnt */
	do {
		c = next_line ();
	} while (strchr (pattern, c) == NULL);
	unput (c);
}

int next_line (void) {

	while (input () != '\n')
		;

return (input ());
}

void InitLexer (void)		// LEX rücksetzen
{
	yy_init = true;
}

